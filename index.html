<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebAuthn SaaS æ¸¬è©¦çµ‚ç«¯</title>
    <style>
        :root { --primary: #0070f3; --bg: #f4f4f5; --card: #ffffff; --text: #18181b; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; background-color: var(--bg); color: var(--text); display: flex; justify-content: center; padding-top: 50px; }
        .container { background: var(--card); padding: 2rem; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.08); width: 400px; }
        h2 { margin-top: 0; text-align: center; color: var(--primary); }
        .form-group { margin-bottom: 1rem; }
        label { display: block; font-size: 0.875rem; font-weight: 600; margin-bottom: 0.5rem; }
        input { width: 100%; padding: 10px; border: 1px solid #e4e4e7; border-radius: 6px; box-sizing: border-box; font-size: 1rem; }
        .btn-group { display: flex; gap: 10px; margin-top: 1.5rem; }
        button { flex: 1; padding: 10px; border: none; border-radius: 6px; font-weight: 600; cursor: pointer; transition: 0.2s; }
        #btn-reg { background-color: var(--primary); color: white; }
        #btn-login { background-color: #27272a; color: white; }
        button:hover { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #logs { margin-top: 1.5rem; background: #18181b; color: #00ff9d; padding: 1rem; border-radius: 6px; font-family: monospace; font-size: 0.8rem; height: 200px; overflow-y: auto; white-space: pre-wrap; }
        .config-section { border-bottom: 1px solid #eee; padding-bottom: 1rem; margin-bottom: 1rem; }
    </style>
</head>
<body>

<div class="container">
    <h2>ğŸ” WebAuthn æ¸¬è©¦</h2>
    
    <div class="config-section">
        <div class="form-group">
            <label>API Endpoint</label>
            <input type="text" id="apiUrl" value="http://localhost:8080">
        </div>
        <div class="form-group">
            <label>Tenant API Key (æŸ¥è³‡æ–™åº«)</label>
            <input type="text" id="apiKey" placeholder="è¼¸å…¥ tenants è¡¨ä¸­çš„ api_key">
        </div>
    </div>

    <div class="form-group">
        <label>ä½¿ç”¨è€…åç¨± (Username)</label>
        <input type="text" id="username" placeholder="user@example.com" value="testuser">
    </div>

    <div class="btn-group">
        <button id="btn-reg" onclick="handleRegister()">ğŸ–ï¸ è¨»å†ŠæŒ‡ç´‹</button>
        <button id="btn-login" onclick="handleLogin()">ğŸ”‘ é©—è­‰ç™»å…¥</button>
    </div>

    <div id="logs">ç³»çµ±æº–å‚™å°±ç·’...</div>
</div>

<script>
    // ==========================================
    // æ ¸å¿ƒé‚è¼¯
    // ==========================================

    async function handleRegister() {
        if (!validateInputs()) return;
        const { apiUrl, apiKey, username } = getInputs();
        log('ğŸš€ é–‹å§‹è¨»å†Šæµç¨‹...', true);

        try {
            // 1. å–å¾—è¨»å†Šé¸é … (Get Options)
            log('æ­£åœ¨è«‹æ±‚è¨»å†Šåƒæ•¸...');
            const beginRes = await fetch(`${apiUrl}/register/begin`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey },
                body: JSON.stringify({ username })
            });

            if (!beginRes.ok) throw new Error(await beginRes.text());
            const { options, internalUserId } = await beginRes.json();

            // âš ï¸ é—œéµè½‰æ›ï¼šServer å‚³ä¾†çš„æ˜¯ Base64URL å­—ä¸²ï¼ŒWebAuthn API éœ€è¦ ArrayBuffer
            options.challenge = base64UrlToBuffer(options.challenge);
            options.user.id = base64UrlToBuffer(options.user.id);
            if (options.excludeCredentials) {
                options.excludeCredentials.forEach(cred => cred.id = base64UrlToBuffer(cred.id));
            }

            // 2. å–šèµ·ç€è¦½å™¨ç”Ÿç‰©è¾¨è­˜
            log('è«‹é€²è¡Œç”Ÿç‰©è¾¨è­˜é©—è­‰...');
            const credential = await navigator.credentials.create({ publicKey: options });

            // 3. è½‰æ›å›å‚³è³‡æ–™ (ArrayBuffer -> Base64URL String) ä»¥ä¾¿å‚³å› Server
            const credentialPayload = {
                id: credential.id,
                rawId: bufferToBase64Url(credential.rawId),
                response: {
                    attestationObject: bufferToBase64Url(credential.response.attestationObject),
                    clientDataJSON: bufferToBase64Url(credential.response.clientDataJSON),
                    transports: credential.response.getTransports ? credential.response.getTransports() : []
                },
                type: credential.type,
                clientExtensionResults: credential.getClientExtensionResults()
            };

            // 4. å®Œæˆè¨»å†Š
            log('æ­£åœ¨å‚³é€ç°½ç« è‡³ä¼ºæœå™¨...');
            const finishRes = await fetch(`${apiUrl}/register/finish`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey },
                body: JSON.stringify({ internalUserId, credential: credentialPayload })
            });

            const result = await finishRes.json();
            if (result.verified) {
                log('âœ… è¨»å†ŠæˆåŠŸï¼è£ç½®å·²ç¶å®šã€‚');
            } else {
                log('âŒ è¨»å†Šå¤±æ•—: ' + JSON.stringify(result));
            }

        } catch (err) {
            log('âŒ ç™¼ç”ŸéŒ¯èª¤: ' + err.message);
            console.error(err);
        }
    }

    async function handleLogin() {
        if (!validateInputs()) return;
        const { apiUrl, apiKey, username } = getInputs();
        log('ğŸš€ é–‹å§‹ç™»å…¥æµç¨‹...', true);

        try {
            // 1. å–å¾—ç™»å…¥é¸é …
            log('æ­£åœ¨è«‹æ±‚ç™»å…¥åƒæ•¸...');
            const beginRes = await fetch(`${apiUrl}/login/begin`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey },
                body: JSON.stringify({ username })
            });

            if (!beginRes.ok) throw new Error(await beginRes.text());
            const { options, internalUserId } = await beginRes.json();

            // âš ï¸ é—œéµè½‰æ›ï¼šChallenge å’Œ AllowCredentials éƒ½è¦è½‰ Buffer
            options.challenge = base64UrlToBuffer(options.challenge);
            if (options.allowCredentials) {
                options.allowCredentials.forEach(cred => cred.id = base64UrlToBuffer(cred.id));
            }

            // 2. å–šèµ·é©—è­‰
            log('è«‹é©—è­‰æ‚¨çš„æŒ‡ç´‹/FaceID...');
            const credential = await navigator.credentials.get({ publicKey: options });

            // 3. è½‰æ›å›å‚³è³‡æ–™
            const credentialPayload = {
                id: credential.id,
                rawId: bufferToBase64Url(credential.rawId),
                response: {
                    authenticatorData: bufferToBase64Url(credential.response.authenticatorData),
                    clientDataJSON: bufferToBase64Url(credential.response.clientDataJSON),
                    signature: bufferToBase64Url(credential.response.signature),
                    userHandle: credential.response.userHandle ? bufferToBase64Url(credential.response.userHandle) : null
                },
                type: credential.type,
                clientExtensionResults: credential.getClientExtensionResults()
            };

            // 4. å®Œæˆç™»å…¥
            log('æ­£åœ¨é©—è­‰ç°½ç« ...');
            const finishRes = await fetch(`${apiUrl}/login/finish`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'x-api-key': apiKey },
                body: JSON.stringify({ internalUserId, credential: credentialPayload })
            });

            const result = await finishRes.json();
            if (result.verified) {
                log('ğŸ‰ ç™»å…¥æˆåŠŸï¼æ­¡è¿å›ä¾†ã€‚');
            } else {
                log('âŒ ç™»å…¥å¤±æ•—: ' + JSON.stringify(result));
            }

        } catch (err) {
            log('âŒ ç™¼ç”ŸéŒ¯èª¤: ' + err.message);
            console.error(err);
        }
    }

    // ==========================================
    // å·¥å…·å‡½å¼ï¼šBase64URL <-> ArrayBuffer è½‰æ›
    // ==========================================
    
    function bufferToBase64Url(buffer) {
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.byteLength; i++) {
            binary += String.fromCharCode(bytes[i]);
        }
        return btoa(binary)
            .replace(/\+/g, '-')
            .replace(/\//g, '_')
            .replace(/=/g, '');
    }

    function base64UrlToBuffer(base64url) {
        const padding = '='.repeat((4 - base64url.length % 4) % 4);
        const base64 = (base64url + padding)
            .replace(/-/g, '+')
            .replace(/_/g, '/');
        const rawData = atob(base64);
        const outputArray = new Uint8Array(rawData.length);
        for (let i = 0; i < rawData.length; ++i) {
            outputArray[i] = rawData.charCodeAt(i);
        }
        return outputArray.buffer;
    }

    // ==========================================
    // UI è¼”åŠ©
    // ==========================================

    function getInputs() {
        return {
            apiUrl: document.getElementById('apiUrl').value.replace(/\/$/, ''),
            apiKey: document.getElementById('apiKey').value,
            username: document.getElementById('username').value
        };
    }

    function validateInputs() {
        const { apiKey, username } = getInputs();
        if (!apiKey) { alert('è«‹è¼¸å…¥ API Key'); return false; }
        if (!username) { alert('è«‹è¼¸å…¥ä½¿ç”¨è€…åç¨±'); return false; }
        return true;
    }

    function log(msg, clear = false) {
        const el = document.getElementById('logs');
        if (clear) el.innerHTML = '';
        const time = new Date().toLocaleTimeString();
        el.innerHTML += `[${time}] ${msg}\n`;
        el.scrollTop = el.scrollHeight;
    }
</script>

</body>
</html>